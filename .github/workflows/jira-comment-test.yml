name: Manual Jira Comment Test

on:
  workflow_dispatch:
    inputs:
      jiraKey:
        description: "Jira issue key (e.g., EDGE-123). If empty, keys will be parsed from commit/branch"
        required: false
        default: ""
      commitMessage:
        description: "Commit message to test (can contain URLs, PR #123, demo/preview/live URLs)"
        required: true
        default: "EDGE-123 Test commit message with demo: https://example.aem.page/path"
      branchName:
        description: "Branch name to test (keys will be parsed from this)"
        required: true
        default: "feat-EDGE-123-test"
      dryRun:
        description: "If true, only print the payload instead of posting to Jira"
        required: true
        default: "true"
      prNumber:
        description: "Optional PR number to link (e.g., 42)"
        required: false
        default: ""

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Jira ADF payload (manual test)
        id: build
        env:
          INPUT_JIRA_KEY: ${{ github.event.inputs.jiraKey }}
          INPUT_COMMIT_MESSAGE: ${{ github.event.inputs.commitMessage }}
          INPUT_BRANCH_NAME: ${{ github.event.inputs.branchName }}
          INPUT_DRY_RUN: ${{ github.event.inputs.dryRun }}
          INPUT_PR_NUMBER: ${{ github.event.inputs.prNumber }}
        run: |
          python3 - << 'PY'
          import json, re, os

          key_re = re.compile(r"\b[A-Z][A-Z0-9]+-\d+\b")

          def create_adf_hyperlink(text, url):
              return {
                  "type": "text",
                  "text": text,
                  "marks": [
                      {
                          "type": "link",
                          "attrs": {
                              "href": url
                          }
                      }
                  ]
              }

          def create_adf_text(text):
              return {"type": "text", "text": text}

          def convert_urls_in_text(text):
              url_pattern = r'https?://[^\s<>'"""{}|\\^`\[\]]+[^\s<>'"""{}|\\^`\[\].,;:!?\'")\]]'
              result = []
              last_end = 0
              for match in re.finditer(url_pattern, text):
                  if match.start() > last_end:
                      before_text = text[last_end:match.start()]
                      if before_text:
                          result.append(create_adf_text(before_text))
                  url = match.group(0).rstrip('.,;:!?"\'/)')
                  display_text = (url[:30] + "..." + url[-27:]) if len(url) > 60 else url
                  result.append(create_adf_hyperlink(display_text, url))
                  last_end = match.end()
              if last_end < len(text):
                  remaining = text[last_end:]
                  if remaining:
                      result.append(create_adf_text(remaining))
              if not result:
                  result.append(create_adf_text(text))
              return result

          # Inputs
          manual_key = os.environ.get("INPUT_JIRA_KEY", "").strip()
          commit_message = os.environ.get("INPUT_COMMIT_MESSAGE", "").strip()
          branch_name = os.environ.get("INPUT_BRANCH_NAME", "").strip()
          pr_number = os.environ.get("INPUT_PR_NUMBER", "").strip()

          # Derive keys
          keys = set()
          if manual_key:
              keys.update(key_re.findall(manual_key))
          keys.update(key_re.findall(branch_name))
          keys.update(key_re.findall(commit_message))

          if not keys:
              print("No Jira keys found in inputs; nothing to build")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("payloads=[]\n")
              raise SystemExit(0)

          content = []
          # 1) commit message with URL conversion
          content.extend(convert_urls_in_text(commit_message + "\n"))

          # 2) fake commit URL using repo context for realism
          repo = os.environ.get('GITHUB_REPOSITORY', '')
          server = os.environ.get('GITHUB_SERVER_URL', 'https://github.com')
          fake_sha = 'deadbeef'
          commit_url = f"{server}/{repo}/commit/{fake_sha}"
          content.append(create_adf_text("GitHub Commit: "))
          content.append(create_adf_hyperlink(fake_sha, commit_url))
          content.append(create_adf_text("\n"))

          # 3) optional PR link
          if pr_number:
              pr_url = f"{server}/{repo}/pull/{pr_number}"
              content.append(create_adf_text("Pull Request: "))
              content.append(create_adf_hyperlink(f"#{pr_number}", pr_url))
              content.append(create_adf_text("\n"))

          # 4) demo/preview/live patterns inside commit message
          demo_patterns = [
              r'demo[:\s]+([^\s"\'<>]+)',
              r'preview[:\s]+([^\s"\'<>]+)',
              r'live[:\s]+([^\s"\'<>]+)'
          ]
          for pattern in demo_patterns:
              m = re.search(pattern, commit_message, re.IGNORECASE)
              if m:
                  demo_url = m.group(1).rstrip('.,;:!?"\'/)')
                  if not demo_url.startswith('http'):
                      demo_url = f"https://{demo_url}"
                  content.append(create_adf_text("Demo Page: "))
                  content.append(create_adf_hyperlink("View Demo", demo_url))
                  content.append(create_adf_text("\n"))
                  break

          line_content = {"type": "paragraph", "content": content}

          payloads = []
          for k in sorted(keys):
              adf_comment = {"type": "doc", "version": 1, "content": [line_content]}
              payloads.append({"key": k, "comment": adf_comment})

          print("Payloads to send:")
          print(json.dumps(payloads, indent=2))

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"payloads={json.dumps(payloads)}\n")
          PY

      - name: Post to Jira (optional)
        if: ${{ steps.build.outputs.payloads != '' && steps.build.outputs.payloads != '[]' && github.event.inputs.dryRun != 'true' }}
        env:
          PAYLOADS: ${{ steps.build.outputs.payloads }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        run: |
          python3 - << 'PY'
          import json, os, base64, urllib.request

          payloads = json.loads(os.environ["PAYLOADS"])
          jira = os.environ["JIRA_BASE_URL"].rstrip("/")
          auth = (os.environ["JIRA_EMAIL"] + ":" + os.environ["JIRA_API_TOKEN"]).encode()
          b64 = base64.b64encode(auth).decode()

          for p in payloads:
              url = f"{jira}/rest/api/3/issue/{p['key']}/comment"
              comment_body = {"body": p["comment"]}
              data = json.dumps(comment_body).encode()
              req = urllib.request.Request(url, data=data, headers={
                  "Authorization": f"Basic {b64}",
                  "Accept": "application/json",
                  "Content-Type": "application/json"
              })
              try:
                  with urllib.request.urlopen(req) as resp:
                      print(p["key"], "->", resp.status)
              except Exception as e:
                  print("Failed", p["key"], e)
          PY
